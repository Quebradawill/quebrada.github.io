---
layout: post
title: 算法设计与分析-北京大学-屈婉玲
date: 2019-10-23
categories: Programming
tags: C++ 北大算法
status: publish
type: post
published: true
author: Quebradawill
---

## 1. 分治策略

### 1.1 设计思想

**分治策略（Divide and Conquer ）：**1. 将原始问题划分或者归约为规模较小的子问题，子问题与原问题具有相同的性质 ，子问题的求解彼此独立，划分时子问题的规模尽可能均衡；2. 子问题规模足够小时可直接求解；3. 递归或迭代求解每个子问题；4. 将子问题的解综合得到原问题的解。

**递归和迭代的区别：**<br>
递归过程中，问题的规模在缩小，这样最终得到问题的解；而迭代是一种由远变近的逼近，问题的规模不见得缩小了，但是慢慢在调整接近答案。递归求解 $n$ 的阶乘过程，非常符合这个描述；而数值分析课程里的许多方法，比如牛顿迭代法，也是符合这个描述的。<br>
一句话：递归是自己调用自己，每次旨在<font color='blue'>缩小问题规模</font>。迭代是自己执行很多次，每次旨在<font color='blue'>更接近目标</font>。<br>
循环和迭代的共同点在于，它们都是在描述一个**多次操作**。不同点在于，<font color='blue'>循环</font>侧重于描述每次操作和上一次操作**相同**之处，而<font color='blue'>迭代</font>侧重于描述每次操作和上一次操作的**不同**之处。

**注意：**1. 子问题与原始问题性质完全一样；2. 子问题之间可彼此独立地求解；3. 递归停止时子问题可直接求解。

### 1.2 应用实例

芯片测试、快速排序、幂乘算法。

### 1.3 改进分治算法的途径

**减少子问题数**：适用于子问题个数多，划分和综合工作量不太大；利用子问题的依赖关系，用某些子问题解的代数表达式表示另一些子问题的解，减少独立计算子问题个数，使某些子问题的解通过组合其他子问题的解而得到；综合解的工作量可能会增加，但增加的工作量不影响 问题复杂度 $W(n)$ 的阶。

**增加预处理**

### 1.4 典型的分治算法

选择问题：选第 $k$ 小，选第二大，选最大与最小，选最大。

信号平滑处理：快速傅立叶变换 FFT 算法，卷积计算，卷积及应用。

计算几何：计算平面点集的凸包。

#### 1.4.1 选最大最小

**分组算法：**<br>1. 将 $n$ 个元素两两一组分成 $\lfloor n/2 \rfloor$ 组；<br>2. 每组比较，得到 $\lfloor n/2 \rfloor$ 个较小和 $\lfloor n/2 \rfloor$ 个较大；<br>3. 在 $\lceil n/2 \rceil$ 个较大（含轮空元素）中找最大 $\max$；<br>4. 在 $\lceil n/2 \rceil$ 个较小（含轮空元素）中找最小 $\min$。

**分治算法：**<br>1. 将数组 $L$ 从中间划分为两个子数组 $L_1$ 和 $L_2$；<br>2. 递归地在 $L_1$ 中求最大 $\max_1$ 和最小 $\min_1$；<br>3. 递归地在 $L_2$ 中求最大 $\max_2$ 和最小 $\min_2$；<br>4. $\max \leftarrow \max \{\max_1, \max_2 \}$；<br>5. $\min \leftarrow \min \{\min_1, \min_2 \}$。

#### 1.4.2 选第二大

提高效率的途径，在确定最大数的过程中记录下被最大数直接淘汰的元素。设计思想：用空间换时间。

**锦标赛算法：**<br>1. 两两分组比较，大者进入下一轮，直到剩下一个元素 $\max$ 为止；<br>2. 在每次比较中淘汰较小元素，将被淘汰元素记录在淘汰它的元素链表上；<br>3. 检查 $\max$ 的链表，从中找到最大元，即 $\textrm{second}$。

#### 1.4.3 一般选择问题的算法设计

管道位置：如何选择主管道的位置，使得支管道长度的总和最小？最优解：$y$ 坐标的中位数。<font color='red'>结论是否成立？</font>

**分治算法：**<br>假设元素彼此不等，设计思想：<br>1. 用某个元素 $m^*$ 作为标准将 $S$ 划分成 $S_1$ 与 $S_2$，其中 $S_1$ 的元素小于 $m^*$，$S_2$ 的元素大于 $m^*$；<br>2. 如果 $k \leq \vert S_1 \vert $，则在 $S_1$ 中找第 $k$ 小，如果 $k=\vert S_1 \vert + 1$，则 $m^*$ 是第 $k$ 小，如果 $k > \vert S_1 \vert + 1$，则在 $S_2$ 中找第 $k - \vert S_1 \vert - 1$ 小。



## 2. 动态规划

### 2.1 设计思想

动态规划（Dynamic Programming）：求解过程是<font color='magenta'>多阶段决策</font>过程，每步处理一个子问题，可用于求解组合优化问题。

### 2.1 设计思想

动态规划（Dynamic Programming）：求解过程是<font color='magenta'>多阶段决策</font>过程，每步处理一个子问题，可用于求解组合优化问题。

**适用条件：**问题要满足<font color='magenta'>优化原则</font>或<font color='magenta'>最优子结构</font>性质，即： 一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列。

**动态规划设计要素：**1. 问题建模，优化的目标函数是什么？约束条件是什么？2. 如何划分子问题（边界）？3. 问题的优化函数值与子问题的优化函数值存在 着什么依赖关系？（递推方程）4. 是否满足优化原则？5. 最小子问题怎样界定？其优化函数值，即初值等于什么？

**动态规划算法设计要素：**多阶段决策过程，每步处理一个子问题，界定子问题的边界。列出优化函数的递推方程及初值。问题要满足优化原则或最优子结构性质，即： 一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列。

### 2.2 应用实例

**实例1：矩阵相乘基本运算次数**

矩阵 $P,Q$ 的大小分别为 $p\times q$ 和 $q \times r $，则 $ P \times Q $ 的基本运算次数为 $ p \times q \times r $。

蛮力算法：加 $n$ 个括号的方法有 $\frac{1}{n+1} \binom {2n}{n}$ ，是一个 Catalan 数，是指数级别。

动态规划算法：（1）子问题划分：矩阵链 $A_i A_{i+1} \cdots A_j$，边界向量 $i,j$，输入向量：$<P_{i-1} P_i \cdots P_j>$，其最好划分运算次数：$m[i,j]$。（2）子划分的依赖：最优划分最后一次相乘发生在矩阵 $k$ 的位置，即 $ A_{i \cdots j} = A_{i \cdots k} A_{k + 1 \cdots j}$。（3）递推方程为：
$$
m[i,j] = \left\{\begin{array}
00 & i=j \\ 
\min_{i \leq k < j} \{ m[i,k] + m[k+1,j] + P_{i-1} P_k P_j \} & i < j
\end{array}\right.
$$


## 3. 贪心法

## 4. 回溯与分支限界