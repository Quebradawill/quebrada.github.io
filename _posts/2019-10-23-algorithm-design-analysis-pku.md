---
layout: post
title: 算法设计与分析-北京大学-屈婉玲
date: 2019-10-23
categories: Programming
tags: C++ 北大算法
status: publish
type: post
published: true
author: Quebradawill
---

## 1. 分治策略

### 1.1 设计思想

**分治策略（Divide and Conquer ）：**1. 将原始问题划分或者归约为规模较小的子问题，子问题与原问题具有相同的性质 ，子问题的求解彼此独立，划分时子问题的规模尽可能均衡；2. 子问题规模足够小时可直接求解；3. 递归或迭代求解每个子问题；4. 将子问题的解综合得到原问题的解。

**递归和迭代的区别：**<br>
递归过程中，问题的规模在缩小，这样最终得到问题的解；而迭代是一种由远变近的逼近，问题的规模不见得缩小了，但是慢慢在调整接近答案。递归求解 $n$ 的阶乘过程，非常符合这个描述；而数值分析课程里的许多方法，比如牛顿迭代法，也是符合这个描述的。<br>
一句话：递归是自己调用自己，每次旨在<font color='blue'>缩小问题规模</font>。迭代是自己执行很多次，每次旨在<font color='blue'>更接近目标</font>。<br>
循环和迭代的共同点在于，它们都是在描述一个**多次操作**。不同点在于，<font color='blue'>循环</font>侧重于描述每次操作和上一次操作**相同**之处，而<font color='blue'>迭代</font>侧重于描述每次操作和上一次操作的**不同**之处。

**注意：**1. 子问题与原始问题性质完全一样；2. 子问题之间可彼此独立地求解；3. 递归停止时子问题可直接求解。

### 1.2 应用实例

芯片测试、快速排序、幂乘算法。

### 1.3 改进分治算法的途径

**减少子问题数**：适用于子问题个数多，划分和综合工作量不太大；利用子问题的依赖关系，用某些子问题解的代数表达式表示另一些子问题的解，减少独立计算子问题个数，使某些子问题的解通过组合其他子问题的解而得到；综合解的工作量可能会增加，但增加的工作量不影响 问题复杂度 $W(n)$ 的阶。

**增加预处理**

### 1.4 典型的分治算法

选择问题：选第 $k$ 小，选第二大，选最大与最小，选最大。

信号平滑处理：快速傅立叶变换 FFT 算法，卷积计算，卷积及应用。

计算几何：计算平面点集的凸包。

#### 1.4.1 选最大最小

**分组算法：**<br>1. 将 $n$ 个元素两两一组分成 $\lfloor n/2 \rfloor$ 组；<br>2. 每组比较，得到 $\lfloor n/2 \rfloor$ 个较小和 $\lfloor n/2 \rfloor$ 个较大；<br>3. 在 $\lceil n/2 \rceil$ 个较大（含轮空元素）中找最大 $\max$；<br>4. 在 $\lceil n/2 \rceil$ 个较小（含轮空元素）中找最小 $\min$。

**分治算法：**<br>1. 将数组 $L$ 从中间划分为两个子数组 $L_1$ 和 $L_2$；<br>2. 递归地在 $L_1$ 中求最大 $\max_1$ 和最小 $\min_1$；<br>3. 递归地在 $L_2$ 中求最大 $\max_2$ 和最小 $\min_2$；<br>4. $\max \leftarrow \max \{\max_1, \max_2 \}$；<br>5. $\min \leftarrow \min \{\min_1, \min_2 \}$。

#### 1.4.2 选第二大

提高效率的途径，在确定最大数的过程中记录下被最大数直接淘汰的元素。设计思想：用空间换时间。

**锦标赛算法：**<br>1. 两两分组比较，大者进入下一轮，直到剩下一个元素 $\max$ 为止；<br>2. 在每次比较中淘汰较小元素，将被淘汰元素记录在淘汰它的元素链表上；<br>3. 检查 $\max$ 的链表，从中找到最大元，即 $\textrm{second}$。

#### 1.4.3 一般选择问题的算法设计

管道位置：如何选择主管道的位置，使得支管道长度的总和最小？最优解：$y$ 坐标的中位数。<font color='red'>结论是否成立？</font>

**分治算法：**<br>假设元素彼此不等，设计思想：<br>1. 用某个元素 $m^{\star}$ 作为标准将 $S$ 划分成 $S_1$ 与 $S_2$，其中 $S_1$ 的元素小于 $m^{\star}$，$S_2$ 的元素大于 $m^{\star}$；<br>2. 如果 $k \leq \vert S_1 \vert $，则在 $S_1$ 中找第 $k$ 小，如果 $k=\vert S_1 \vert + 1$，则 $m^{\star}$ 是第 $k$ 小，如果 $k > \vert S_1 \vert + 1$，则在 $S_2$ 中找第 $k - \vert S_1 \vert - 1$ 小。

#### 1.4.4 卷积及其应用

给定向量 $a = (a_0, a_1, \cdots, a_{n-1}), b = (b_0, b_1, \cdots, b_{n-1})$，卷积为 $a*b = (c_0, c_1, \cdots, c_{2n-2})$，其中 $c_k = \sum_{i+j=k, i,j <n} a_i b_j, k = 0, 1, \cdots, 2n-2$。

#### 1.4.5 平面点集的凸包

算法思想：<br>1. 以连接最大纵坐标点 $y_{\max}$ 和最小纵坐标点 $y_{\min}$ 的线段 $d$ 划分 $L$ 为左点集 $L_{\textrm{left}}$ 和右点集  $L_{\textrm{right}}$；（<font color='blue'>当然连接最大横坐标点和最小横坐标点应该也是可以的</font>）<br>2. $\textrm{Deal}(L_{\textrm{left}})$；$\textrm{Deal}(L_{\textrm{right}})$。

$\textrm{Deal}(L_{\textrm{left}})$<br>1. 以 $d$ 和距离 $d$ 最远点 $P$ 构成三角形，$P$ 加入凸包，另外两条边分别记作 $a$ 和 $b$；<br>2. 检查 $L_{\textrm{left}}$ 中其他点是否在三角形内；在三角形内，则从 $L_{\textrm{left}}$ 中删除；否则根据在 $a$ 或 $b$ 边的外侧划分在两个子问题中；<br>3. $\textrm{Deal}(a)$；<br>4. $\textrm{Deal}(b)$。

## 2. 动态规划

### 2.1 设计思想

动态规划（Dynamic Programming）：求解过程是<font color='magenta'>多阶段决策</font>过程，每步处理一个子问题，可用于求解组合优化问题。

### 2.1 设计思想

动态规划（Dynamic Programming）：求解过程是<font color='magenta'>多阶段决策</font>过程，每步处理一个子问题，可用于求解组合优化问题。

**适用条件：**问题要满足<font color='magenta'>优化原则</font>或<font color='magenta'>最优子结构</font>性质，即： 一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列。

**动态规划设计要素：**1. 问题建模，优化的目标函数是什么？约束条件是什么？2. 如何划分子问题（边界）？3. 问题的优化函数值与子问题的优化函数值存在 着什么依赖关系？（递推方程）4. 是否满足优化原则？5. 最小子问题怎样界定？其优化函数值，即初值等于什么？

**动态规划算法设计要素：**多阶段决策过程，每步处理一个子问题，界定子问题的边界。列出优化函数的递推方程及初值。问题要满足优化原则或最优子结构性质，即：一个最优决策序列的任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列。

**动态规划算法的递归实现**：<br>1. 与蛮力算法相比较，动态规划算法利用了子问题优化函数间的依赖关系，时间复杂度有所降低；<br>2. 动态规划算法的递归实现效率不高，原因在于同一子问题多次重复出现，每次出现都需要重新计算一遍；<br>3. 采用空间换时间策略，记录每个子问题首次计算结果，后面再用时就直接取值，每个子问题只算一次。

**动态规划算法的迭代实现**：<br>1. 每个子问题只计算一次；<br>2. 迭代过程：从最小的子问题算起；考虑计算顺序，以保证后面用到的值前面已经计算好；存储结构保存计算结果——备忘录；<br>3. 解的追踪：设计标记函数标记每步的决策；考虑根据标记函数追踪解的算法。

**递归实现和迭代实现的比较：**<br>1. 递归实现：时间复杂性高，空间较小；迭代实现：时间复杂性低，空间消耗多。<br>2. 原因：递归实现子问题多次重复计算，子问题计算次数呈指数增长，迭代实现每个子问题只计算一次。<br>3. 动态规划时间复杂度：备忘录各项计算量之和+追踪解工作量；通常追踪工作量不超过计算工作量，是问题规模的多项式函数。

**动态规划算法的要素：**<br>1. 划分子问题，确定子问题边界，将问题求解转变成多步判断的过程；<br>2. 定义优化函数，以该函数极大（或极小）值作为依据，确定是否满足优化原则；<br>3. 考虑是否需要设立标记函数；<br>4. 列优化函数的递推方程和边界条件；<br>5. 自底向上计算，设计备忘录（表格）；<br>6. 用递推方程或备忘录估计时间复杂度。

### 2.2 应用实例

**实例1：矩阵相乘基本运算次数**

矩阵 $P,Q$ 的大小分别为 $p\times q$ 和 $q \times r $，则 $ P \times Q $ 的基本运算次数为 $ p \times q \times r $。

蛮力算法：加 $n$ 个括号的方法有 $\frac{1}{n+1} \binom {2n}{n}$ ，是一个 Catalan 数，是指数级别。

动态规划算法：（1）子问题划分：矩阵链 $A_i A_{i+1} \cdots A_j$，边界向量 $i,j$，输入向量：$<P_{i-1} P_i \cdots P_j>$，其最好划分运算次数：$m[i,j]$。（2）子划分的依赖：最优划分最后一次相乘发生在矩阵 $k$ 的位置，即 $ A_{i \cdots j} = A_{i \cdots k} A_{k + 1 \cdots j}$。（3）递推方程为：
$$
m[i,j] = \left\{\begin{array}
00 & i=j \\ 
\min_{i \leq k < j} \{ m[i,k] + m[k+1,j] + P_{i-1} P_k P_j \} & i < j
\end{array}\right.
$$


## 3. 贪心法

## 4. 回溯与分支限界